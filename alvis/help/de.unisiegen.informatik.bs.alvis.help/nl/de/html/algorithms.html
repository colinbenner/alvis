<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Algorithmen schreiben</title>
</head>

<body>
<h1>Algorithmen schreiben</h1>
<h2>Einführung</h2>
Die Syntax von Alvis' Algorithmenprogrammiersprache wurde inspiriert durch verschiedene Programmiersprachen, sowie die Pseudo-Code-Syntax, die in <q>Algorithmen &ndash; Eine Einführung</q> von Cormen, Leiserson, Rivest und Stein verwendet wird.

Ein <q>hello world</q>-Programm kann etwa so aussehen:<br>
<pre>
/*
 * The main function.
 */
main() {
	// print using Java's System.out.println() method
	print("Hello, ");
	print("world!"),
}
</pre>
Man kann hier die beiden zur Verfügung stehenden Kommentararten sehen: mehrzeilige Kommentare die mit <code>/*</code> beginnen und mit <code>*/</code> enden und mit <code>//</code> eingeleitete Kommentare, die den Rest der Zeile zum Kommentar machen.

Jeder Algorithmus benötigt einen <code>main</code>-Funktion. Das ist die Funktion, die von Alvis aufgerufen wird, wenn man einen Algorithmus ausführt. Sie entspricht der <code>main</code>-Funktion bei C, C++, C#, Java, etc.


<h2>Bezeichner</h2>
Bezeichner sind Zeichenketten, die mit einem großen oder kleinen ASCII-Buchstaben (d.h. <q>A</q>,<q>B</q>,<q>C</q>,&hellip;,<q>Z</q> oder <q>a</q>,<q>b</q>,<q>c</q>,&hellip;,<q>z</q>) oder einem Unterstrich (d.h. <q>_</q>) beginnen.
Nach diesem ersten Zeichen dürfen weitere Zeichen dieser Art sowie die Ziffern <q>0</q>,<q>1</q><q>2</q>,&hellip;,<q>9</q> benutzt werden.

<h2>Konstanten</h2>
Es gibt Konstanten für folgendes:
<ul>
	<li>Boolesche Werte: <q>true</q> und <q>false</q></li>
	<li>Ganzzahlen werden dargestellt als Ketten von Ziffern <q>0</q>, &hellip;, <q>9</q>,
	zum Beispiel:<br><q>1</q>, <q>23</q>, <q>623843824</q>, <q>1234567890</q>, <q>42</q></li>
	<li>Fließkommazahlen sind ebensolche Zeichenketten gefolgt von einem Punkt (<q>.</q>) auf welchen dann beliebig viele weiter Ziffern folgen dürfen. Beispielsweise:<br>
	<q>3.</q>, <q>2.71828</q>, <q>0.1234567890876543</q></li>
	<li>Zeichenketten werden mit doppelten Anführungszeichen eingefasst <q>"</q>. Innerhalb dieses gibt es die Escape-Sequenzen
	<ul>
		<li>Backspace-Zeichen <q>\b</q></li>
		<li>Tabulator-Zeichen <q>\t</q></li>
		<li>Newline-Zeichen <q>\n</q></li>
		<li>Formfeed-Zeichen <q>\f</q></li>
		<li>Wagenrücklauf-Zeichen <q>\r</q></li>
		<li>Einfaches Anführungszeichen (<q>'</q>): <q>\'</q></li>
		<li>Doppeltes Anführungszeichen (<q>"</q>): <q>\"</q></li>
		<li>Backslash (<q>\</q>): <q>\\</q></li>
	</ul>
	Zum Beispiel "abc", "", "a\"bcd\"efg\n"</li>
	<li><q>null</q> als Platzhalterwert für beliebige Typen</li>
	<li><q>infty</q> als Darstellung eines typspezifischen unendlichen Elements. So sind etwa die beiden Zeilen
	<pre>
Float a = 1/0,
Float a = infty,
	</pre>
	äquivalent.
	</li>
</ul>


<h2>Ausdrücke</h2>
<p>Ausdrücke können die folgenden konstruiert werden.
<ul>
	<li>Eine Konstante ist ein Ausdruck</li>
	<li>Wenn <code>a</code> und <code>b</code> Konstanten sind, so sind auch <code>a op b</code> Ausdrücke, wobei <code>op</code> einer der Operatoren
		<q>+</q>, <q>-</q>, <q>*</q>, <q>/</q>, <q>%</q>, <q>&lt;</q>, <q>&gt;</q>, <q>&lt;=</q>, <q>&gt;=</q>, <q>==</q>, <q>!=</q>, <q>||</q>, <q>&amp;&amp;</q> ist.</li>
	<li>Wenn <code>a</code> ein Ausdruck ist, so ist es auch <code>(+ a)</code>, <code>(- a)</code> und <code>! a</code> ein Ausdruck.</li>
	<li>Wenn <code>a</code> ein Ausdruck ist, so auch <code>(a)</code>.</li>
	<li>Ein Postfix-Ausdruck ist eine Ausdruck.</li>
</ul>
Nichts außer dem so definierten ist ein Ausdruck. </p>

<p> Postfix-Ausdrücke haben eine der folgenden Formen.
<ul>
	<li><code>id</code>, wobei <code>id</code> ein Bezeichner ist.</li>
	<li><code>postfixExpression.id</code> wobei <code>a</code> ein Bezeichner ist.</li>
	<li><code>postfixExpression(argumentList)</code>, wobei argumentList eine beliebig lange Liste von durch Kommata getrennte Ausdrücke ist.</li>
	<li><code>postfixExpressino[a]</code>, wobei <code>a</code> ein Ausdruck ist.</li>
</ul>
Nichts außer dem so definierten ist ein Postfix-Ausdruck.</p>



<h2>Typen</h2>
Typen sind entweder einfach Typen wie <code>Integer</code> (Ganzzahlen), <code>Float</code> (Fließkommazahlen), <code>String</code> (Zeichenkette) oder <code>Void</code> (Typ der ein leeres Funktionsergebnis darstellt),
zusammengesetzte Typen wie <code>Integer List</code>, was eine Liste von Ganzzahlen beschreibt oder Array-Typen wie
<code>Integer[]</code> (Array mit ganzzahligen Elementen) oder <code>Float[][][]</code> (Array aus Arrays aus Arrays mit Fließkommazahlen als Elementen).

<p>
Einfache Typen und zusammengesetzte Typen können Unter- oder Obertypen anderer Typen sein.
Sind <code>A</code> und <code>B</code> Typen, wobei <code>B</code> durch Vererbung aus <code>A</code> hervorgeht,
so nennen wir <code>A</code> einen echten Obertypen von <code>B</code> und <code>B</code> einen echten Untertypen von <code>A</code>.
Sind <code>A</code> und <code>B</code> gleich, so nennen wir auch <code>A</code> Untertyp von <code>B</code> und <code>B</code> Untertype von <code>A</code>.
</p>



<h2>Anweisungs-End-Zeichen</h2>
<p>
Es gibt zwei verschiedene Zeichen, die das Ende einer Anweisung markieren: <q>;</q> und <q>,</q>, die man beide im <q>hello world</q>-Programm oben sehen kann.
<q>,</q> markiert nur das Ende einer Anweisung.
<q>;</q> markiert das Ende einer Anweisung und fügt einen Breakpoint nach der Anweisung ein.
Damit kann man Alvis mitteilen, an welchen Stellen die Ausführung des Algorithmus unterbrochen werden soll, so dass man sich angucken kann, wie der momentane Zustand aussieht.
</p>

<p>
Im Folgenden wird in der Dokumentation nur noch Kommata verwendet werden. An jeder Stelle, an der ein Komma steht könnte aber genauso auch ein Semikolon stehen. 
</p>


<h2>Anweisungen</h2>
<ul>
	<li>Eine Deklaration ist eine Anweisung.</li>
	<li>Eine Zuweisung ist eine Anweisung.</li>
	<li>Eine return-Anweisung ist eine Anweisung.</li>
	<li>Ein Funktions- oder Methodenaufruf ist eine Anweisung.</li>
	<li>Jeder Block ist eine Anweisung.</li>
	<li>Ein if-statement ist eine Anweisung.</li>
	<li>Eine for-Schliefe ist eine Anweisung.</li>
	<li>Eine while-Schliefe ist eine Anweisung.</li>
</ul>
Nichts außer dem so definierten ist eine Anweisung.


<h2>Deklarationen</h2>
Eine Deklaration hat die gleiche Form wie in C oder Java:
<pre>
T id,
</pre>
oder in Kombination mit einer Zuweisung
<pre>
T id = expr,
</pre>
wobei <code>T</code> ein Typ, <code>id</code> ein Bezeichner und <code>expr</code> ein Ausdruck ist, der als Typ einen Untertype von <code>T</code> hat.


<h2>Zuweisungen</h2>
<p>
Zuweisungen haben die gleich Form wie in C oder in Java:
<pre>
a = 3,
</pre>
wobei <code>a</code> diese Anweisung sich im Gültigkeitsbereich der Variable <code>a</code> befinden muss.
Weiterhin muss der Typ der linken Seite ein Obertype des Typs der rechten Seite sein.
</p>

<p>Im gegensetz zu C oder Java ist es aber nicht möglich
<pre>
a = b = 3,
</pre>
statt
<pre>
b = 3,
a = b,
</pre>
zu benutzen, da in Alvis' Algorithmensprache Zuweisungen Anweisungen aber keine Ausdrücke sind.
</p>

Wie oben erwähnt ist es möglich eine Kombination von Deklaration und Zuweisung zu verwenden.


<h2>return-Ausdruck</h2>
<p>
Ein return-Ausdruck hat die gleiche Form, wie einer in C oder Java:
<pre>
return,
</pre>
in einer Funktion die keine Werte zurückgibt, oder
<pre>
return expr,
</pre>
in einer Funktion, die einen Wert zurückgibt, dessen Typ ein Obertyp des Ausdrucks <code>expr</code> sein muss.
</p>

<p>
An dieser Stelle ist zu beachten, dass Alvis am Ende eines return-Ausdrucks ein Semikolon stillschweigend ignoriert.
Das liegt daran, dass die Ausführung nach einem return-Ausdruck an verschiedenen Stellen im Quelltext weitergehen kann, je nachdem, von wo aus die Funktion, die den return-Ausdruck enthält aufgerufen wird.
Dadurch ist es nicht möglich im generierten Code automatisch einen Breakpoint einzufügen.

Möchte den Ablauf des Algorithmus nach verlassen einer Funktion dennoch pausieren, so kann man einfach ein Semikolon hinter den Ausdruck mit dem entsprechenden Funktionsaufruf setzten.
</p>


<h2>Blöcke</h2>
Es gibt zwei Möglichkeiten Blöcke zu Schreiben.
Ein Block ist eine Liste von Anweisungen, die umfasst werden von <q>{</q> am Anfang und <q>}</q> am Ende (C-Stil) oder von <q>begin</q> am Anfang und <q>end</q> am Ende.


<h2>if-statements</h2>
<p>
if-statements haben die folgenden Formen:
<pre>
if condition:
	then_block
</pre>
und
<pre>
if condition:
	then_block
else
	else_block
</pre>
wobei <code>then_block</code> und <code>else_block</code> Anweisungen sind und <code>condition</code> ein Ausdruck mit einem Typ, der Untertyp vom eingebauten Typ <code>Boolean</code> ist, ist.
</p>

<p>
Der folgende Code ist zunächst uneindeutig:
<pre>
if condition1:
if condition2:
	then_block
else
	else_block
</pre>
Es ist hier nicht sofort klar, zu welchem <code>if</code> das <code>else</code> gehört. In solchen Fällen geht Alvis analog zu C und Java davon aus, dass
<pre>
 if condition1: {
	if condition2:
		then_block
	else
		else_block
}
</pre>
gemeint war, dass also im Zweifel das <code>else</code> immer zum letzen infrage kommenden <code>if</code> gehört, das noch kein <code>else</code> besitzt.
</p>


<h2>Schleifen</h2>
<p>
Es gibt zwei Arten von Schliefen in Alvis' Sprache. Zum einen gibt es die for-Schliefe, die man auch foreach-Schleife nennen könnte<br>
<pre>
for Type id in someArray:
	block
</pre>
wobei <code>Type</code> ein Typname, <code>id</code> ein Bezeichner, <code>someArray</code> ein Ausdruck von dessen Typ ein Array-Typ ist, dessen Elemente als Typ einen Untertyp von <code>Type</code> haben und <code>block</code> ein Ausdruck ist.
Diese Schliefe iteriert über alle Elemente in <code>someArray</code>, wobei bei jedem Schleifendurchlauf das aktuelle Element in <code>id</code> gespeichert ist.
<code>id</code> ist dabei nur innerhalb von <code>block</code> gültig.
</p>


<p>
Die andere Schleife ist eine while-Schleife. Die Syntax dafür ist:<br>
<pre>
while condition:
	block
</pre>
wobei <code>condition</code> ein Ausdrück von einem Untertyp von Boolean ist und <code>block</code> ein Ausdruck ist.
<code>block</code> wird so lange ausgeführt, wie <code>condition</code> <code>true</code> ist.


</body>
</html>
